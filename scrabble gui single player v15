import tkinter as tk
from tkinter import messagebox
from tkinter import colorchooser
import pandas as pd
from itertools import repeat
import random
from tkinter import simpledialog
from itertools import filterfalse
import numpy as np
import more_itertools as mit
import sys
import os

#----seting up the window:
scrab = tk.Tk()
scrab.geometry("1100x775")
scrab.config(bg="#008c17")
scrab.title("pyScrabble")
scrab.resizable(False,False)
scrab.iconbitmap(r"C:\Users\zeina\Documents\codin\atom files\scrabble tile p.ico")

#----title and subtitle made:
title = tk.Label(text="pyScrabble", fg="#fcdc90", bg="#008c17")
title.grid(column=1, row=0, padx=110)
title.config(font=("Fixedsys", 50))
subtitle= tk.Label(text="A scrabble game powered by Python!", bg="#008c17", fg="#fcdc90")
subtitle.grid(column=1,row=2, sticky="NSEW")
subtitle.config(font=("Fixedsys", 13))

#-----created top menu:
s_menu = tk.Menu(master=scrab)
scrab.config(menu=s_menu)

#----list of coloured tile indices, so these can be avoided when player customises colours:
c_tiles = [0,3,7,11,14,16,20,24,28,32,36,38,42,45,48,52,56,59,64,70,76,80,84,88,92,96,98,102,105,108,112,116,119,122,126,128,132,136,140,144,148,154,160,165,168,172,176,179,182,186,188,192,196,200,204,208,210,213,217,221,224]

#----functions for menu options:
#shows a messagebox with the rules
def rules():
    tk.messagebox.askokcancel(title="Scrabble Rules", message="""
    Welcome to pyScrabble!
    The rules are very similar to traditional Scrabble. You are randomly assigned a series of letters from a virtual bag. Each letter has a point score attached to it, roughly corresponding to how commonly it is used in English. To get these juicy points added to your score, simply make a valid word using that letter.
    A valid word is one that is found in our dictionary, which allows for both British and American spellings of most English words.
    Click on the letter you want to use, then click on the board where you want to place it. Once you click on a letter, it becomes disabled, so it's best to plan your word first.
    There are coloured tiles which, depending on their colour, will multiply either the total score of the word or the individual letter if your word/letter is placed on top of it.
    Once you've finished your word, click "Next Turn". If you are successful, your points will be added. Otherwise you will get a message telling you the word is invalid. You will have another chance, but three wrong words in a row will end the game :(
    Alternatively, if you don't think you see any words, you can press "Skip Turn", which will put your letters back in the bag and give you new ones. You can't skip more than one time in a row.
    Also, there is a small selection of bonus words, which will give you even more points. These words are secret (unless you cheat) and are broadly related to computer science. Generally, abbreviations and acronyms do not count as valid words, except for a few of these bonus words.
    You can only make one word at a time, and if you make multiple words (by connecting words for example), the highest scoring valid word will be taken.
    At the end of the game, which you can bring on if you click "End Game", your score may be added to the High Score Board if you did well enough.
     Depending on how you acquired this game, you may have a text file that stores these scores, called "scrabble_hi_scores.txt". If not, you can simply create a file with this name, in the same directory as this game, to enable this feature.
     There are still bugs here and there but it's very playable!
     Good luck! ðŸ˜‰ðŸ‘
    """)

#uses the colour picker to change the background colours according to user choice
def picker():
    colour = colorchooser.askcolor()[1]
    scrab.config(bg=colour)
    title.config(bg=colour)
    subtitle.config(bg=colour)
    scorecard.config(bg=colour)
    score1.config(bg=colour)
    scorep1.config(bg=colour)
    scoren1.config(bg=colour)
    letterpanel.config(bg=colour)
    letter_1.config(bg=colour)
    letter_2.config(bg=colour)
    letter_3.config(bg=colour)
    letter_4.config(bg=colour)
    letter_5.config(bg=colour)
    letter_6.config(bg=colour)
    letter_7.config(bg=colour)
    letter1.config(bg=colour)
    letter2.config(bg=colour)
    letter3.config(bg=colour)
    letter4.config(bg=colour)
    letter5.config(bg=colour)
    letter6.config(bg=colour)
    letter7.config(bg=colour)
    key.config(bg=colour)
    val1.config(bg=colour)
    val2.config(bg=colour)
    val3.config(bg=colour)
    val4.config(bg=colour)
    val5.config(bg=colour)
    val6.config(bg=colour)
    val7.config(bg=colour)
    key_inf.config(bg=colour)
    red_lab.config(bg=colour)
    blue_lab.config(bg=colour)
    l_blue_lab.config(bg=colour)
    yellow_lab.config(bg=colour)
    letters_label.config(bg=colour)
    board_frame.config(bg=colour)
    for i in filterfalse(lambda i: i in c_tiles[0:225], range(1,225)):
            squares[i].config(bg=colour)
    turn.config(bg=colour)
    skip.config(bg=colour)
    one_player_lab.config(bg=colour)
    end_game_btn.config(bg=colour)

#uses the colour picker to change highlight and text colours based on player's choice
def picker2():
    colour2 = colorchooser.askcolor()[1]
    title.config(fg=colour2)
    subtitle.config(fg=colour2)
    scorecard.config(highlightbackground=colour2)
    score1.config(fg=colour2)
    scorep1.config(fg=colour2)
    scoren1.config(fg=colour2)
    val1.config(fg=colour2)
    val2.config(fg=colour2)
    val3.config(fg=colour2)
    val4.config(fg=colour2)
    val5.config(fg=colour2)
    val6.config(fg=colour2)
    val7.config(fg=colour2)
    letter1.config(highlightbackground=colour2)
    letter2.config(highlightbackground=colour2)
    letter3.config(highlightbackground=colour2)
    letter4.config(highlightbackground=colour2)
    letter5.config(highlightbackground=colour2)
    letter6.config(highlightbackground=colour2)
    letter7.config(highlightbackground=colour2)
    board_frame.config(highlightbackground=colour2)
    letterpanel.config(highlightbackground=colour2)
    letters_label.config(fg=colour2)
    letter_1.config(fg=colour2)
    letter_2.config(fg=colour2)
    letter_3.config(fg=colour2)
    letter_4.config(fg=colour2)
    letter_5.config(fg=colour2)
    letter_6.config(fg=colour2)
    letter_7.config(fg=colour2)
    key_inf.config(fg=colour2)
    key.config(highlightbackground=colour2)
    red_lab.config(fg=colour2)
    blue_lab.config(fg=colour2)
    l_blue_lab.config(fg=colour2)
    yellow_lab.config(fg=colour2)
    red.config(highlightbackground=colour2)
    blue.config(highlightbackground=colour2)
    l_blue.config(highlightbackground=colour2)
    yellow.config(highlightbackground=colour2)
    for i in filterfalse(lambda i: i in c_tiles[0:225], range(1,225)):
            squares[i].config(fg=colour2, disabledforeground=colour2)
    turn_frame.config(highlightbackground=colour2)
    turn.config(fg=colour2)
    skip_frame.config(highlightbackground=colour2)
    skip.config(fg=colour2)
    one_player_lab.config(fg=colour2)
    end_game_btn.config(fg=colour2)
    end_frame.config(highlightbackground=colour2)

#changes the player's name based on input
def player_name():
    players = tk.simpledialog.askstring(title="Player Names", prompt="""Please enter your name:
    """, parent=scrab)
    scorep1.config(text=players)

#shows current high score board, from txt file
def high_scores_show():
    scoreboard = open("scrabble_hi_scores.txt","r")
    high_scores = scoreboard.readlines()
    with open("scrabble_hi_scores.txt") as f:
        scores_to_show = f.readlines()
    formatted_scores = ""
    score_strip = []
    for i in high_scores:
        score_strip.append(i.strip("\n "))
    final_sort = sorted(score_strip, key=lambda x: int(x[x.index(":")+2:]), reverse=True)
    for c,v in enumerate(final_sort[:10]):
        formatted_scores+="{}. {}\n".format(c+1,v)
    tk.messagebox.askokcancel(title="High Scores", message= formatted_scores if len(high_scores)>0 else "No Scores to Show Yet" , parent=scrab)

#-------cheat code function, bit hacky, won't work if one of the keys involved is pressed but the whole code is not played
code_list = []
def cheat_code(event):
    global code_list
    code_list.append(str(event))
    stripped_codes = []
    base_codes = []
    for i in code_list:
        stripped_codes.append(i.split("keysym=")[1])
    for i in stripped_codes:
        base_codes.append(i.split(" ")[0])
    if base_codes == ['Up', 'Up', 'Down', 'Down', 'Left', 'Right', 'Left', 'Right', 'b', 'a']:
        scoren1.config(text=int(scoren1.cget("text"))+50)

scrab.bind("<Up>", cheat_code)
scrab.bind("<Up>", cheat_code)
scrab.bind("<Down>", cheat_code)
scrab.bind("<Down>", cheat_code)
scrab.bind("<Left>", cheat_code)
scrab.bind("<Right>", cheat_code)
scrab.bind("<Left>", cheat_code)
scrab.bind("<Right>", cheat_code)
scrab.bind("<b>", cheat_code)
scrab.bind("<a>", cheat_code)

#-------making a series of lists and variables that will be used in game
#creating word builder that will store the letters as they're played
current_word = []
#tracking squares, letters used, points, for validating words including connecting current turn to the letters on the board
current_sq = []
used_squares = []
current_sq_index = []
current_array_index = []
current_word_str = ""
current_word_p = 0
#variables for building compound words from this turn combined with those on the board
new_full_string = []
side_add = ""
word = ""
#tracking blank letters for switching
blanks_used = 0
#list for words that have been made
words_made = []
#list of bonus words
the_snitch = "python"
bonus_words = ["data","algorithm","agile","scrabble","bool","go","java","php","ruby","javascript","c","cpp","swift","shell","css","html",
"shell","git","basic","sql","matlab","perl","tkinter","gui","api","fortran","scala","rust","pandas","numpy","itertools", "konami"]
#-multiplier list and dict for tracking multipliers on current word to work out score with
letter_mult = {}
word_mult = []

#-----making 2d array to back gui grid and store letters added
row1 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row2 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row3 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row4 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row5 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row6 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row7 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row8 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row9 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row10 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row11 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row12 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row13 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row14 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
row15 = [" ", " ", " "," "," "," "," "," "," "," "," "," "," "," "," "]
board_array = np.array([row1,row2,row3,row4,row5,row6,row7,row8,row9,row10,row11,row12,row13,row14,row15])

#-----function to add letters to the board
def board_func(square):
    global current_sq
    global letter_mult
    global word_mult
    global current_sq_index
    global current_array_index
    global blanks_used

    #handles blank letter, allows player to enter the letter they want
    if active_letter==" ":
        blank = tk.simpledialog.askstring(title="Blank Letter Entry", prompt="""Please enter any letter you wish to use. One letter only:
        """, parent=scrab)
        square.config(text=blank[0].upper(), state=tk.DISABLED)
        current_word.append(blank[0])
        #checks whether a mutiplier used and tracks
        if square.cget("bg")=="red":
            word_mult.append(3)
        if square.cget("bg")=="yellow":
            word_mult.append(2)
        if square.cget("bg")=="blue":
            letter_mult[active_letter.lower()]=3
        if square.cget("bg")=="#ADD8E6":
            letter_mult[active_letter.lower()]=2
        else:
            word_mult.append(1)
        #tracking of where on the board is occupied, adds letters from gui board to the array version of the board
        current_sq.append(square)
        square_ind = squares.index(square)
        current_sq_index.append(square_ind)
        board_array[square_ind//15, square_ind%15] = active_letter
        current_array_index.append([square_ind//15, square_ind%15])
        blanks_used+=1

    #does the same as above, adding to the board and the array based on what letter has been selected for non blank tiles
    else:
        square.config(text=active_letter, state=tk.DISABLED)
        current_word.append(active_letter)
        if square.cget("bg")=="red":
            word_mult.append(3)
        if square.cget("bg")=="yellow":
            word_mult.append(2)
        if square.cget("bg")=="blue":
            letter_mult[active_letter.lower()]=3
        if square.cget("bg")=="#ADD8E6":
            letter_mult[active_letter.lower()]=2
        else:
            word_mult.append(1)
        current_sq.append(square)
        square_ind = squares.index(square)
        current_sq_index.append(square_ind)
        board_array[square_ind//15, square_ind%15] = active_letter
        current_array_index.append([square_ind//15, square_ind%15])

#variable for active letter:
active_letter = ""

#----making the menu bar and each part of it, each points to a command/function that it will trigger:
file_menu = tk.Menu(s_menu, tearoff=False)
s_menu.add_cascade(label="File", menu=file_menu)
file_menu.add_command(label="High Scores", command=high_scores_show)
file_menu.add_separator()
file_menu.add_command(label="Exit", command=scrab.quit)

custom_menu = tk.Menu(s_menu, tearoff=False)
s_menu.add_cascade(label="Customise", menu=custom_menu)
custom_menu.add_command(label="Change Background Colour", command=picker)
custom_menu.add_separator()
custom_menu.add_command(label="Change Text Colour", command = picker2)
custom_menu.add_separator()
custom_menu.add_command(label="Change Player Name", command = player_name)

help_menu = tk.Menu(s_menu, tearoff=False)
s_menu.add_cascade(label="Help", menu=help_menu)
help_menu.add_command(label="Rules", command=rules)

#----creating the score section
#frame around it and title
scorecard = tk.Frame(height=530, width=250, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
scorecard.grid(row=1, column=0, padx=15)
score1 = tk.Label(master=scorecard, text="Score:", bg="#008c17", fg="#fcdc90")
score1.grid(row=0, column=0, pady=36, padx=25)
score1.configure(font=("Fixedsys", 20))
#player name
scorep1 = tk.Label(master=scorecard, text="Player", bg="#008c17", fg="#fcdc90")
scorep1.grid(row=1, column=0)
scorep1.configure(font=("Fixedsys", 15))
#score number
scoren1 = tk.Label(master=scorecard, text="0", bg="#008c17", fg="#fcdc90")
scoren1.grid(row=2, column=0, pady=50)
scoren1.configure(font=("Fixedsys", 35))

#----creating the board as buttons in the gui, storing in a list to be able to acess the objects/widgets themselves with the index:
squares = []
board_frame = tk.Frame(highlightbackground="#fcdc90", highlightthickness=2, borderwidth=20, bg="#008c17", width=500, height=500)
board_frame.grid(row=1, column=1)
for x in range(15):
    for y in range(15):
        square = tk.Button(master=board_frame, width=2, height=1, bg="#008c17", text = " ", fg="#fcdc90", disabledforeground="#fcdc90")
        square.config(command=lambda square=square: board_func(square))
        square.config(font=("Fixedsys"))
        square.grid(row=x, column=y, sticky="nsew")
        squares.append(square)

#-----setting colours for multiplier squares:
squares[0].config(bg="red", fg="black", disabledforeground="black")
squares[3].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[7].config(bg="red", fg="black", disabledforeground="black")
squares[11].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[14].config(bg="red", fg="black", disabledforeground="black")
squares[16].config(bg="yellow", fg="black", disabledforeground="black")
squares[20].config(bg="blue", fg="white", disabledforeground="white")
squares[24].config(bg="blue", fg="white", disabledforeground="white")
squares[28].config(bg="yellow", fg="black", disabledforeground="black")
squares[32].config(bg="yellow", fg="black", disabledforeground="black")
squares[36].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[38].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[42].config(bg="yellow", fg="black", disabledforeground="black")
squares[45].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[48].config(bg="yellow", fg="black", disabledforeground="black")
squares[52].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[56].config(bg="yellow", fg="black", disabledforeground="black")
squares[59].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[64].config(bg="yellow", fg="black", disabledforeground="black")
squares[70].config(bg="yellow", fg="black", disabledforeground="black")
squares[76].config(bg="blue", fg="white", disabledforeground="white")
squares[80].config(bg="blue", fg="white", disabledforeground="white")
squares[84].config(bg="blue", fg="white", disabledforeground="white")
squares[88].config(bg="blue", fg="white", disabledforeground="white")
squares[92].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[96].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[98].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[102].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[105].config(bg="red", fg="black", disabledforeground="black")
squares[108].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[112].config(bg="yellow", fg="black", disabledforeground="black")
squares[116].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[119].config(bg="red", fg="black", disabledforeground="black")
squares[122].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[126].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[128].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[132].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[136].config(bg="blue", fg="white", disabledforeground="white")
squares[140].config(bg="blue", fg="white", disabledforeground="white")
squares[144].config(bg="blue", fg="white", disabledforeground="white")
squares[148].config(bg="blue", fg="white", disabledforeground="white")
squares[154].config(bg="yellow", fg="black", disabledforeground="black")
squares[160].config(bg="yellow", fg="black", disabledforeground="black")
squares[165].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[168].config(bg="yellow", fg="black", disabledforeground="black")
squares[172].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[176].config(bg="yellow", fg="black", disabledforeground="black")
squares[179].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[182].config(bg="yellow", fg="black", disabledforeground="black")
squares[186].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[188].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[192].config(bg="yellow", fg="black", disabledforeground="black")
squares[196].config(bg="yellow", fg="black", disabledforeground="black")
squares[200].config(bg="blue", fg="white", disabledforeground="white")
squares[204].config(bg="blue", fg="white", disabledforeground="white")
squares[208].config(bg="yellow", fg="black", disabledforeground="black")
squares[210].config(bg="red", fg="black", disabledforeground="black")
squares[213].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[217].config(bg="red", fg="black", disabledforeground="black")
squares[221].config(bg="#ADD8E6", fg="black", disabledforeground="black")
squares[224].config(bg="red", fg="black", disabledforeground="black")

#function for each of the letter buttons which will make the letter the active one when pressed, so it can then be added to the board
def letter_go1():
    global active_letter
    active_letter = str(letter_1['text'])
    letter_1.config(state=tk.DISABLED)
def letter_go2():
    global active_letter
    active_letter = str(letter_2['text'])
    letter_2.config(state=tk.DISABLED)
def letter_go3():
    global active_letter
    active_letter = str(letter_3['text'])
    letter_3.config(state=tk.DISABLED)
def letter_go4():
    global active_letter
    active_letter = str(letter_4['text'])
    letter_4.config(state=tk.DISABLED)
def letter_go5():
    global active_letter
    active_letter = str(letter_5['text'])
    letter_5.config(state=tk.DISABLED)
def letter_go6():
    global active_letter
    active_letter = str(letter_6['text'])
    letter_6.config(state=tk.DISABLED)
def letter_go7():
    global active_letter
    active_letter = str(letter_7['text'])
    letter_7.config(state=tk.DISABLED)

#------making the section for letters to be displayed, that player can choose from:
#frame and title
letterpanel = tk.Frame(height=530, width=250, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letterpanel.grid(row=1, column=2)
letters_label = tk.Label(master=letterpanel, bg="#008c17", fg="#fcdc90", text="Your Letters:")
letters_label.grid(pady=5, padx=15)
letters_label.config(font=("Fixedsys", 20))

#making button for each of 7 letters, with ability to display the letter and its score, adding placeholder 'X' as letter
letter1= tk.Frame(master=letterpanel,height=50, width=50, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letter1.grid(pady=5)
letter_1= tk.Button(master=letter1, text="X", bg="#008c17", fg="#fcdc90", width=4, command=letter_go1)
letter_1.config(font=("Fixedsys",15))
letter_1.grid()
val1= tk.Label(master=letter1, text="X", bg="#008c17", fg="#fcdc90")
val1.config(font=("Fixedsys",7))
val1.grid()

letter2= tk.Frame(master=letterpanel,height=50, width=50, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letter2.grid(pady=5)
letter_2= tk.Button(master=letter2, text="X", bg="#008c17", fg="#fcdc90", width=4, command=letter_go2)
letter_2.config(font=("Fixedsys",15))
letter_2.grid()
val2= tk.Label(master=letter2, text="X", bg="#008c17", fg="#fcdc90")
val2.config(font=("Fixedsys",7))
val2.grid()

letter3= tk.Frame(master=letterpanel,height=50, width=50, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letter3.grid(pady=5)
letter_3= tk.Button(master=letter3, text="X", bg="#008c17", fg="#fcdc90", width=4, command=letter_go3)
letter_3.config(font=("Fixedsys",15))
letter_3.grid()
val3= tk.Label(master=letter3, text="X", bg="#008c17", fg="#fcdc90")
val3.config(font=("Fixedsys",7))
val3.grid()

letter4= tk.Frame(master=letterpanel,height=50, width=50, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letter4.grid(pady=5)
letter_4= tk.Button(master=letter4, text="X", bg="#008c17", fg="#fcdc90", width=4, command=letter_go4)
letter_4.config(font=("Fixedsys",15))
letter_4.grid()
val4= tk.Label(master=letter4, text="X", bg="#008c17", fg="#fcdc90")
val4.config(font=("Fixedsys",7))
val4.grid()

letter5= tk.Frame(master=letterpanel,height=50, width=50, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letter5.grid(pady=5)
letter_5= tk.Button(master=letter5, text="X", bg="#008c17", fg="#fcdc90", width=4, command=letter_go5)
letter_5.config(font=("Fixedsys",15))
letter_5.grid()
val5= tk.Label(master=letter5, text="X", bg="#008c17", fg="#fcdc90")
val5.config(font=("Fixedsys",7))
val5.grid()

letter6= tk.Frame(master=letterpanel,height=50, width=50, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letter6.grid(pady=5)
letter_6= tk.Button(master=letter6, text="X", bg="#008c17", fg="#fcdc90", width=4, command=letter_go6)
letter_6.config(font=("Fixedsys",15))
letter_6.grid()
val6= tk.Label(master=letter6, text="X", bg="#008c17", fg="#fcdc90")
val6.config(font=("Fixedsys",7))
val6.grid()

letter7= tk.Frame(master=letterpanel,height=50, width=50, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
letter7.grid(pady=5)
letter_7= tk.Button(master=letter7, text="X", bg="#008c17", fg="#fcdc90", width=4, command=letter_go7)
letter_7.config(font=("Fixedsys",15))
letter_7.grid()
val7= tk.Label(master=letter7, text="X", bg="#008c17", fg="#fcdc90")
val7.config(font=("Fixedsys",7))
val7.grid()

#----making the key to square colours and their meanings
#frame and title
key = tk.Frame(height=50, width=500, highlightthickness=2, highlightbackground="#fcdc90", bg="#008c17")
key.grid(row=0, column=0, padx=20,sticky="S")
key_inf = tk.Label(master=key,text="Colour Key:", bg="#008c17", fg="#fcdc90")
key_inf.grid(columnspan=2,  padx=20)
key_inf.config(font=("Fixedsys", 15))

#going through each colour, giving sample of colour and writing what it means
red = tk.Frame(master=key, height=10, width=10, bg="red", highlightbackground="#fcdc90", highlightthickness=1)
red.grid(row=1, column=0)
red_lab = tk.Label(master=key, text="- Triple Word", bg="#008c17", fg="#fcdc90")
red_lab.grid(row=1, column=1)
red_lab.config(font=("Fixedsys",5))

yellow = tk.Frame(master=key, height=10, width=10, bg="yellow", highlightbackground="#fcdc90", highlightthickness=1)
yellow.grid(row=2, column=0)
yellow_lab = tk.Label(master=key, text="- Double Word", bg="#008c17", fg="#fcdc90")
yellow_lab.grid(row=2, column=1)
yellow_lab.config(font=("Fixedsys",5))

l_blue = tk.Frame(master=key, height=10, width=10, bg="#ADD8E6", highlightbackground="#fcdc90", highlightthickness=1)
l_blue.grid(row=3, column=0)
l_blue_lab = tk.Label(master=key, text="- Double Letter", bg="#008c17", fg="#fcdc90")
l_blue_lab.grid(row=3, column=1)
l_blue_lab.config(font=("Fixedsys",5))

blue = tk.Frame(master=key, height=10, width=10, bg="blue", highlightbackground="#fcdc90", highlightthickness=1)
blue.grid(row=4, column=0)
blue_lab = tk.Label(master=key, text="- Triple Letter", bg="#008c17", fg="#fcdc90")
blue_lab.grid(row=4, column=1)
blue_lab.config(font=("Fixedsys",5))

#-----alphabet created:
#creating class
class letters:
    def __init__ (self, letter, score, freq):
        self.letter = letter
        self.score = score
        self.freq = freq
#making each letter
a= letters("a", 1, 9)
b= letters("b",3, 2 )
c= letters("c",3, 2 )
d= letters("d",2, 4 )
e= letters("e",1, 12 )
f= letters("f",4, 2 )
g= letters("g",2, 3 )
h= letters("h",4, 2 )
i= letters("i",1, 9 )
j= letters("j",8,1 )
k= letters("k",5,1 )
l= letters("l",1, 4 )
m= letters("m",3, 2 )
n= letters("n",1, 6 )
o= letters("o",1, 8)
p= letters("p",3, 2 )
q= letters("q",10,1 )
r= letters("r",1, 6 )
s= letters("s",1, 4 )
t= letters("t",1, 6 )
u= letters("u",1, 4 )
v= letters("v",4,2 )
w= letters("w",4,2 )
x= letters("x",8,1 )
y= letters("y",4,2 )
z= letters("z",10,1 )
blank = letters(" ",0,2 )
alphabet = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]

#----creating a list that contains all the words in the dictionary (combining several csv files, lowercasing and flattening into 1d list):
dictionary1= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Aword.csv",squeeze=True, encoding= 'utf-8', error_bad_lines=False)
dictionary2= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Bword.csv", squeeze=True, encoding= 'utf-8', error_bad_lines=False)
dictionary3= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Cword.csv", squeeze=True, encoding='cp1252', error_bad_lines=False)
dictionary4= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Dword.csv", squeeze=True, encoding= 'latin1', error_bad_lines=False)
dictionary5= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Eword.csv", squeeze=True, encoding= 'utf-8')
dictionary6= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Fword.csv", squeeze=True, encoding= 'utf-8')
dictionary7= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Gword.csv", squeeze=True, encoding= 'utf-8')
dictionary8= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Hword.csv", squeeze=True, encoding= 'utf-8')
dictionary9= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Iword.csv", squeeze=True, encoding= 'utf-8')
dictionary10= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Jword.csv", squeeze=True, encoding= 'utf-8')
dictionary11= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Kword.csv", squeeze=True, encoding= 'utf-8')
dictionary12= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Lword.csv", squeeze=True, encoding= 'utf-8')
dictionary13= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Mword.csv", squeeze=True, encoding= 'latin1')
dictionary14= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Nword.csv", squeeze=True, encoding= 'utf-8')
dictionary15= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Oword.csv", squeeze=True, encoding= 'utf-8')
dictionary16= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Pword.csv", squeeze=True, encoding= 'latin1')
dictionary17= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Qword.csv", squeeze=True, encoding= 'utf-8')
dictionary18= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Rword.csv", squeeze=True, encoding= 'utf-8')
dictionary19= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Sword.csv", squeeze=True, encoding= 'latin1')
dictionary20= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Tword.csv", squeeze=True, encoding= 'utf-8')
dictionary21= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Uword.csv", squeeze=True, encoding= 'utf-8')
dictionary22= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Vword.csv", squeeze=True, encoding= 'utf-8')
dictionary23= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Wword.csv", squeeze=True, encoding= 'utf-8')
dictionary24= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Xword.csv", squeeze=True, encoding= 'utf-8')
dictionary25= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Yword.csv", squeeze=True, encoding= 'utf-8')
dictionary26= pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\Word lists in csv\Zword.csv",squeeze=True, encoding= 'utf-8')

fulldict = [dictionary1]+[dictionary2]+[dictionary3]+[dictionary4]+[dictionary5]+[dictionary6]+[dictionary7]+[dictionary8]+[dictionary9]\
+[dictionary10]+[dictionary11]+[dictionary12]+[dictionary13]+[dictionary14]+[dictionary15]+[dictionary16]+[dictionary17]+[dictionary18]\
+[dictionary19]+[dictionary20]+[dictionary21]+[dictionary22]+[dictionary23]+[dictionary24]+[dictionary25]+[dictionary26]

flat_dict = [i.strip().lower() for sub in fulldict for i in sub]
new_dict= list(pd.read_csv(r"C:\Users\zeina\Documents\codin\atom files\dictionary.csv",squeeze=True, encoding= 'utf-8', error_bad_lines=False))

combined_dict = flat_dict+new_dict+bonus_words

#--------creating letter bag that will hold each letter instance:
bag = []
#adding each letter with correct frequency
for letter in repeat(None, a.freq):
    bag.append(a)
for letter in repeat(None, b.freq):
    bag.append(b)
for letter in repeat(None, c.freq):
    bag.append(c)
for letter in repeat(None, d.freq):
    bag.append(d)
for letter in repeat(None, e.freq):
    bag.append(e)
for letter in repeat(None, f.freq):
    bag.append(f)
for letter in repeat(None, g.freq):
    bag.append(g)
for letter in repeat(None, h.freq):
    bag.append(h)
for letter in repeat(None, i.freq):
    bag.append(i)
for letter in repeat(None, j.freq):
    bag.append(j)
for letter in repeat(None, k.freq):
    bag.append(k)
for letter in repeat(None, l.freq):
    bag.append(l)
for letter in repeat(None, m.freq):
    bag.append(m)
for letter in repeat(None, n.freq):
    bag.append(n)
for letter in repeat(None, o.freq):
    bag.append(o)
for letter in repeat(None, p.freq):
    bag.append(p)
for letter in repeat(None, q.freq):
    bag.append(q)
for letter in repeat(None, r.freq):
    bag.append(r)
for letter in repeat(None, s.freq):
    bag.append(s)
for letter in repeat(None, t.freq):
    bag.append(t)
for letter in repeat(None, u.freq):
    bag.append(u)
for letter in repeat(None, v.freq):
    bag.append(v)
for letter in repeat(None, w.freq):
    bag.append(w)
for letter in repeat(None, x.freq):
    bag.append(x)
for letter in repeat(None, y.freq):
    bag.append(y)
for letter in repeat(None, z.freq):
    bag.append(z)
for letter in repeat(None, blank.freq):
    bag.append(blank)

#-----handing out letters from the bag to the playable letter area:
x_letter1 = random.choice(bag)
bag.remove(x_letter1)
letter_1.config(text=x_letter1.letter.capitalize())

x_letter2 = random.choice(bag)
bag.remove(x_letter2)
letter_2.config(text=x_letter2.letter.capitalize())

x_letter3 = random.choice(bag)
bag.remove(x_letter3)
letter_3.config(text=x_letter3.letter.capitalize())

x_letter4 = random.choice(bag)
bag.remove(x_letter4)
letter_4.config(text=x_letter4.letter.capitalize())

x_letter5 = random.choice(bag)
bag.remove(x_letter5)
letter_5.config(text=x_letter5.letter.capitalize())

x_letter6 = random.choice(bag)
bag.remove(x_letter6)
letter_6.config(text=x_letter6.letter.capitalize())

x_letter7 = random.choice(bag)
bag.remove(x_letter7)
letter_7.config(text=x_letter7.letter.capitalize())

#-----adding scores to player letters:
val1.config(text=x_letter1.score)
val2.config(text=x_letter2.score)
val3.config(text=x_letter3.score)
val4.config(text=x_letter4.score)
val5.config(text=x_letter5.score)
val6.config(text=x_letter6.score)
val7.config(text=x_letter7.score)

#----skip limit and wrong words in a row limit
skip_count = 0
wrong_count = 0

#----stats for end of game, to show player their best words
def stats():
    global words_made
    if len(words_made)==0:
        return [0,0]
    else:
        longest = max(words_made, key=len)
        points_dict = {}
        for i in words_made:
            points_dict[i] = sum(globals()[j].score for j in i)
        highest = max(points_dict, key=points_dict.get)
        return [longest,highest]

#-----end game function
def end_game():
    #disabling playable letters
    letter_1.config(state=tk.DISABLED)
    letter_2.config(state=tk.DISABLED)
    letter_3.config(state=tk.DISABLED)
    letter_4.config(state=tk.DISABLED)
    letter_5.config(state=tk.DISABLED)
    letter_6.config(state=tk.DISABLED)
    letter_7.config(state=tk.DISABLED)
    turn.config(state=tk.DISABLED)
    skip.config(state=tk.DISABLED)

    #opening high scores file
    scoreboard = open("scrabble_hi_scores.txt","r")
    high_scores = scoreboard.readlines()

    unformatted_scores = []

    #getting current high scores more readable
    for i in high_scores:
        splitter = i.split(":")
        x = splitter[1].strip("\n ")
        unformatted_scores.append(x)
    #getting top 10 scores
    unformatted_scores = [int(i) for i in unformatted_scores]
    unformatted_scores = sorted(unformatted_scores, reverse=True)[:10]

    #checking if current score is a high score, giving them option to change name for the score board
    if int(scoren1.cget("text"))>min(unformatted_scores) or len(unformatted_scores)<10:
        hi_score_name = tk.simpledialog.askstring(title = "High Score!", prompt=" Congratulations! \n\n You got a HIGH SCORE! \n\n Please enter the name you would like to appear on the high score board:", initialvalue=scorep1.cget("text") , parent=scrab)
        scoreboard = open("scrabble_hi_scores.txt","a")
        scoreboard.write("{}: {}\n".format(hi_score_name,scoren1.cget("text")))
        scoreboard.close()

    #giving best words message
    if stats()[0]!=0:
        goodbye_message = "GG!\n\nLongest Word: {}\nHighest Scoring Word: {}\n\nThanks for playing\n:)".format(stats()[0],stats()[1])
    else:
        goodbye_message = "GG! \n\nPlay more words to see your best words here.\nThanks for playing!\n:) "
    tk.messagebox.askokcancel(message=goodbye_message,title="Bye",parent=scrab)

#--------skip turn function:
def skip_turn():
    global x_letter1
    global x_letter2
    global x_letter3
    global x_letter4
    global x_letter5
    global x_letter6
    global x_letter7
    global skip_count

    #shows message if not able to skip
    if skip_count>0:
        tk.messagebox.askokcancel(title="Skip Limit Reached", message="Sorry! You can't skip more than once in a row")

    #otherwise, puts letters back in bag and gives out new ones
    else:
        skip_count +=1

        bag.append(x_letter1)
        bag.append(x_letter2)
        bag.append(x_letter3)
        bag.append(x_letter4)
        bag.append(x_letter5)
        bag.append(x_letter6)
        bag.append(x_letter7)

        x_letter1 = random.choice(bag)
        bag.remove(x_letter1)
        letter_1.config(text=x_letter1.letter.capitalize())

        x_letter2 = random.choice(bag)
        bag.remove(x_letter2)
        letter_2.config(text=x_letter2.letter.capitalize())

        x_letter3 = random.choice(bag)
        bag.remove(x_letter3)
        letter_3.config(text=x_letter3.letter.capitalize())

        x_letter4 = random.choice(bag)
        bag.remove(x_letter4)
        letter_4.config(text=x_letter4.letter.capitalize())

        x_letter5 = random.choice(bag)
        bag.remove(x_letter5)
        letter_5.config(text=x_letter5.letter.capitalize())

        x_letter6 = random.choice(bag)
        bag.remove(x_letter6)
        letter_6.config(text=x_letter6.letter.capitalize())

        x_letter7 = random.choice(bag)
        bag.remove(x_letter7)
        letter_7.config(text=x_letter7.letter.capitalize())

        #sets score for each new letter
        val1.config(text=x_letter1.score)
        val2.config(text=x_letter2.score)
        val3.config(text=x_letter3.score)
        val4.config(text=x_letter4.score)
        val5.config(text=x_letter5.score)
        val6.config(text=x_letter6.score)
        val7.config(text=x_letter7.score)

#----checking if word in dictionary
#methods for words if just letters played this turn and also combined with letters already on the board, adds all valid words to list
def word_checker():
    global current_word_str
    global new_full_string
    global side_add
    global words_made

    x = ("".join(current_word_str) in combined_dict)
    y = ("".join(new_full_string) in combined_dict)
    z = ("".join(side_add) in combined_dict)
    valid_words = []

    if x==True:
        valid_words.append("".join(current_word_str))
    if y==True:
        valid_words.append("".join(new_full_string))
    if z==True:
        valid_words.append("".join(side_add))
    truth = True if len(valid_words)>0 else False

    if truth == True:
        words_made.append(max(valid_words, key=len))
        return [truth, max(valid_words, key=len)]
    else:
        return ["False", None]

#-----points calculator
added = 0
def points():
    global word
    global added
    new_points = 0
    for i in word:
        new_points += int(globals()[i].score)
    added += (int(scoren1["text"]) + int(new_points))
    scoren1.config(text= added)

#----finding and building word from adjacent letters (beyond the ones played this turn)
#works out what direction the word could continue in and extends based on that if possible
def adjacent_checker():
    global current_word_p
    global current_word_str
    global fulldict
    global new_dict
    global combined_dict
    global added
    global word_mult
    global letter_mult
    global current_sq
    global current_array_index
    global new_full_string

    placed_word_str = "".join(current_word).lower()
    current_word_str = "".join(current_word).lower()
    across_adjacents = []
    down_adjacents = []

    for i in current_sq_index:
        if i%15!=0:
            across_adjacents.append(i-1)
        if (i+1)%15!=0:
            across_adjacents.append(i+1)
        down_adjacents.append(i-15)
        down_adjacents.append(i+15)
    across_adjacents = [i for i in across_adjacents if i not in current_sq_index and 0<i<255]
    down_adjacents = [i for i in down_adjacents if i not in current_sq_index and 0<i<255]
    try:
        if (max(current_sq_index)-min(current_sq_index))/(len(current_sq_index)-1) in [1,15]:
            direction = (max(current_sq_index)-min(current_sq_index))/(len(current_sq_index)-1)
    except:
        direction = "one"
    if len(current_sq_index)==1:
        direction = "one"
    else:
        if (max(current_sq_index)-min(current_sq_index))/(len(current_sq_index)-1) > 15:
            direction = "down"
        else:
            direction = "across"
    if direction == "one":
        if board_array[int(current_array_index[0][0])+1,int(current_array_index[0][1])]!=" ":
            direction = "down"
        if board_array[int(current_array_index[0][0])-1,int(current_array_index[0][1])]!=" ":
            direction = "down"
        elif board_array[int(current_array_index[0][0]),int(current_array_index[0][1])+1]!=" ":
            direction ="across"
        elif board_array[int(current_array_index[0][0]),int(current_array_index[0][1])-1]!=" ":
            direction ="across"
    if direction==1:
        direction = "across"
    if direction==15:
        direction = "down"

    str_plus_adjacent = current_word

    down_min = min([i[0] for i in current_array_index])
    down_max = max([i[0] for i in current_array_index])
    across_min = min([i[1] for i in current_array_index])
    across_max = max([i[1] for i in current_array_index])

    across_adder = []

    if direction =="across":
        c= 0
        for i in board_array[current_array_index[0][0], 0:15]:
            if i!=" ":
                across_adder.append(c)
            c+=1


    new_full_string = []
    if direction =="down":
        x = current_array_index[0][1]
        for i in board_array[down_min:down_max+1,x]:
            new_full_string.append(i)
        if " " not in new_full_string:
            new_full_string = "".join(new_full_string).lower()
    if direction =="across":
        x = current_array_index[0][0]
        for i in board_array[x,across_min:across_max+1]:
            new_full_string.append(i)
        if " " not in new_full_string:
            new_full_string = "".join(new_full_string).lower()


    if direction=="across":
        y = across_min-1
        x = board_array[current_array_index[0][0],y]
        while y>=0 and x!=" ":
            y-=1
        z=0
        if across_max<14:
            z = across_max+1
            a = board_array[current_array_index[0][0],z]
            while z<15 and a!=" ":
                z+=1
        new_full_string = board_array[current_array_index[0][0],min(y,across_min): max(z,across_max)]

    if direction=="down":
        y = down_min-1
        x = board_array[y,current_array_index[0][1]]
        while y>=0 and x!=" ":
            y-=1
        if down_max<14:
            z = down_max+1
            a = board_array[z,current_array_index[0][1]]
            while z<15 and a!=" ":
                z+=1
        for i in current_sq_index:
            if i%15!=0:
                across_adjacents.append(i-1)
            if (i+1)%15!=0:
                across_adjacents.append(i+1)
            down_adjacents.append(i-15)
            down_adjacents.append(i+15)

        across_adjacents = [i for i in across_adjacents if i not in current_sq_index and 0<i<255]
        down_adjacents = [i for i in down_adjacents if i not in current_sq_index and 0<i<255]

        str_plus_adjacent = current_word

    if direction=="across":
        x = min(current_sq_index)-1
        while squares[x].cget("text")!=" ":
            str_plus_adjacent.insert(0,squares[x].cget("text"))
            x-=1
        y = max(current_sq_index)+1
        while y<225 and squares[y].cget("text")!=" ":
            str_plus_adjacent.append(squares[y].cget("text"))
            y+=1

    if direction=="down":
        x = min(current_sq_index)-15
        while squares[x].cget("text")!=" ":
            str_plus_adjacent.insert(0,squares[x].cget("text"))
            x-=15
        y = max(current_sq_index)+15
        while y<225 and squares[y].cget("text")!=" ":
            str_plus_adjacent.append(squares[y].cget("text"))
            y+=15
    side_add = "".join(str_plus_adjacent).lower()

    new_full_string = "".join(new_full_string).lower()
    new_full_string.strip()

#----------next turn function:
def next_turn():
    global current_word_p
    global current_word_str
    global fulldict
    global new_dict
    global combined_dict
    global added
    global word_mult
    global letter_mult
    global current_sq
    global new_full_string
    global side_add
    global word
    global blanks_used
    global skip_count
    global wrong_count

    #checking if all letters are in same row or column
    if len(set(i[0] for i in current_array_index))!=1 and len(set(i[1] for i in current_array_index))!=1:
        tk.messagebox.askokcancel(title="Scrambled",message="Please make sure you use only one row or column!")
        for i in current_sq:
            i.config(text=" ")
        for i in range(1,8):
            x = "letter_{}".format(i)
            globals()[x].config(state=tk.NORMAL)
        current_array_index.clear()
        for i in current_sq:
            i.config(state=tk.NORMAL)
        current_sq.clear()
        letter_mult.clear()
        word_mult.clear()
        current_word.clear()
        current_word_str = ""
        current_sq_index.clear()
        new_full_string = []
        current_array_index.clear()
    else:
        skip_count = 0

    #more validation of potential words made
    adjacent_checker()

    placed_word_str = "".join(current_word).lower()
    current_word_str = "".join(current_word).lower()

    word_bool = word_checker()[0]
    word = word_checker()[1]
    if word in bonus_words:
        word_mult.append(5)
    if word == the_snitch:
        word_mult.append(10)
    for i in range(1,8):
        x = "letter_{}".format(i)
        globals()[x].config(state=tk.NORMAL)

    #replaces only the letters used from the active letter panel, removes from bag and replaces them
    if letter_1.cget("text").lower() in str(placed_word_str) and word_bool==True:
        placed_word_str = placed_word_str.replace(letter_1.cget("text").lower(),"",1)
        x_letter1 = random.choice(bag)
        bag.remove(x_letter1)
        letter_1.config(text=x_letter1.letter.capitalize())
        val1.config(text=x_letter1.score)
    if letter_2.cget("text").lower() in placed_word_str and word_bool==True:
        placed_word_str = placed_word_str.replace(letter_2.cget("text").lower(),"",1)
        x_letter2 = random.choice(bag)
        bag.remove(x_letter2)
        letter_2.config(text=x_letter2.letter.capitalize())
        val2.config(text=x_letter2.score)
    if letter_3.cget("text").lower() in placed_word_str and word_bool==True:
        placed_word_str = placed_word_str.replace(letter_3.cget("text").lower(),"",1)
        x_letter3 = random.choice(bag)
        bag.remove(x_letter3)
        letter_3.config(text=x_letter3.letter.capitalize())
        val3.config(text=x_letter3.score)
    if letter_4.cget("text").lower() in placed_word_str and word_bool==True:
        placed_word_str = placed_word_str.replace(letter_4.cget("text").lower(),"",1)
        x_letter4 = random.choice(bag)
        bag.remove(x_letter4)
        letter_4.config(text=x_letter4.letter.capitalize())
        val4.config(text=x_letter4.score)
    if letter_5.cget("text").lower() in placed_word_str and word_bool==True:
        placed_word_str = placed_word_str.replace(letter_5.cget("text").lower(),"",1)
        x_letter5 = random.choice(bag)
        bag.remove(x_letter5)
        letter_5.config(text=x_letter5.letter.capitalize())
        val5.config(text=x_letter5.score)
    if letter_6.cget("text").lower() in placed_word_str and word_bool==True:
        placed_word_str = placed_word_str.replace(letter_6.cget("text").lower(),"",1)
        x_letter6 = random.choice(bag)
        bag.remove(x_letter6)
        letter_6.config(text=x_letter6.letter.capitalize())
        val6.config(text=x_letter6.score)
    if letter_7.cget("text").lower() in placed_word_str and word_bool==True:
        placed_word_str = placed_word_str.replace(letter_7.cget("text").lower(),"",1)
        x_letter7 = random.choice(bag)
        bag.remove(x_letter7)
        letter_7.config(text=x_letter7.letter.capitalize())
        val7.config(text=x_letter7.score)

    current_word_str = "".join(current_word).lower()

    #calculating score with multipliers, based on stored multipliers of this turn
    new_score = 0
    if all(i not in letter_mult.keys() for i in current_word_str):
        try:
            new_score = int(sum(globals()[i].score for i in word)*int(max(word_mult)))
        except:
            if word==None:
                word_bool='False'
            else:
                for i in word:
                    new_score+=(globals()[i].score)*letter_mult.get(i, 1)
    else:
        if word_bool=='False':
            pass
        else:
            for i in word:
                new_score+=(globals()[i].score)*letter_mult.get(i, 1)
            new_score*=max(word_mult)

    word_bool = word_checker()[0]

    #adding to score if there's a valid word
    if word_bool== True:
        scoren1.configure(text=str(int(scoren1["text"])+new_score))
        wrong_count=0

    #showing warning message and incrementing counter that limits number of wrong words in a row
    elif word_bool=="False":
        tk.messagebox.showinfo(title="Not a Word", message="Sorry! That's not a valid word :( Try again or press \"Skip Turn\" to get new letters")
        wrong_count+=1
        #resetting the board - removing letters just placed and reactivating those squares to be used again
        for i in current_sq:
            i.config(text=" ")
            i.config(state=tk.NORMAL)

    #ending game if too many wrong words in a row
    if wrong_count >=3:
        end_game()

    #resetting what needs to be reset for next turn
    current_sq.clear()
    letter_mult.clear()
    word_mult.clear()
    current_word.clear()
    current_word_str = ""
    current_sq_index.clear()
    new_full_string = []
    current_array_index.clear()

    #resetting the letters active if last turn used blank(s)
    while blanks_used>0:
        if letter_1.cget("text") ==" ":
            x_letter1 = random.choice(bag)
            bag.remove(x_letter1)
            letter_1.config(text=x_letter1.letter.capitalize())
            val1.config(text=x_letter1.score)
            blanks_used -=1
        if letter_2.cget("text") ==" ":
            x_letter2 = random.choice(bag)
            bag.remove(x_letter2)
            letter_2.config(text=x_letter2.letter.capitalize())
            val2.config(text=x_letter2.score)
            blanks_used -=1
        if letter_3.cget("text") ==" ":
            x_letter3 = random.choice(bag)
            bag.remove(x_letter3)
            letter_3.config(text=x_letter3.letter.capitalize())
            val3.config(text=x_letter3.score)
            blanks_used -=1
        if letter_4.cget("text") ==" ":
            x_letter4 = random.choice(bag)
            bag.remove(x_letter4)
            letter_4.config(text=x_letter4.letter.capitalize())
            val4.config(text=x_letter4.score)
            blanks_used -=1
        if letter_5.cget("text") ==" ":
            x_letter5 = random.choice(bag)
            bag.remove(x_letter5)
            letter_5.config(text=x_letter5.letter.capitalize())
            val5.config(text=x_letter5.score)
            blanks_used -=1
        if letter_6.cget("text") ==" ":
            x_letter6 = random.choice(bag)
            bag.remove(x_letter6)
            letter_6.config(text=x_letter6.letter.capitalize())
            val6.config(text=x_letter6.score)
            blanks_used -=1
        if letter_7.cget("text") ==" ":
            x_letter7 = random.choice(bag)
            bag.remove(x_letter7)
            letter_7.config(text=x_letter7.letter.capitalize())
            val7.config(text=x_letter7.score)
            blanks_used -=1

    #letters have run out warning and ending the game
    if len(bag)<=7:
        tk.messagebox.showinfo(title="End of Game!", message="There are no more letters. Letters? None!")
        end_game()

#-------next turn button:
turn_frame = tk.Frame(highlightbackground="#fcdc90", highlightthickness=2)
turn_frame.grid(row=2, column=2)

turn = tk.Button(master=turn_frame, command= next_turn, text="Next Turn", bg="#008c17", fg="#fcdc90", height=2, width=23)
turn.grid(row=2, column=2)
turn.config(font=("Fixedsys", 15))

#------skip turn button
skip_frame = tk.Frame(highlightbackground="#fcdc90", highlightthickness=2)
skip_frame.grid(row=0, column=2)

skip = tk.Button(master=skip_frame, command= skip_turn, text="Skip Turn", bg="#008c17", fg="#fcdc90", height=2, width=23)
skip.grid(row=0, column=2)
skip.config(font=("Fixedsys", 15))

#------------end game button
end_frame = tk.Frame(highlightbackground="#fcdc90", highlightthickness=2)
end_frame.grid(row=2, column=0,pady=20)

end_game_btn = tk.Button(master=end_frame, command= end_game, text="End Game", bg="#008c17", fg="#fcdc90", height=2, width=16)
end_game_btn.grid(row=2, column=0)
end_game_btn.config(font=("Fixedsys", 15))

#----subtitle
one_player_lab = tk.Label(text="Single Player", bg="#008c17", fg="#fcdc90")
one_player_lab.grid(row=0,column=1,sticky="S")
one_player_lab.config(font=("Fixedsys", 15))


#-------running the mainloop
scrab.mainloop()
